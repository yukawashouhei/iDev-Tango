//
//  InitialDataService.swift
//  iDev Tango
//
//  初期データ投入サービス
//  アプリ初回起動時にSwift用語集を自動投入
//

import Foundation
import SwiftData

@MainActor
class InitialDataService {
    static let shared = InitialDataService()
    
    private init() {}
    
    // Swift用語集の初期データ
    private let swiftGlossary: [(term: String, definition: String)] = [
        ("Int", "Intは、整数を扱うための型（データの種類）です。1、100、-5 のような、小数点のない数字を保存するときに使います。"),
        ("型推論", "型推論は、コードから「この変数はたぶんInt型だな」とSwiftが自動で型を推測してくれる機能です。"),
        ("ジェネリクス", "ジェネリクスは、関数や型を定義するときに、扱う型を「仮の型（Tなど）」にしておき、使うときに「実際の型（IntやStringなど）」を指定する機能です。Array<Element> が代表例です。"),
        ("REPL", "REPLは、入力（Read）、実行（Eval）、出力（Print）を繰り返す（Loop）環境のことです。XcodeのPlaygroundなどで、1行ずつコードを試すのに使います。"),
        ("コンパイルエラー", "コンパイルエラーは、書いたコードに文法的な間違いがあり、コンピュータが理解できる言葉（機械語）に翻訳（コンパイル）できないときに発生するエラーです。"),
        ("camelcase", "camelcaseは、myVariableName のように、単語の区切りを大文字にしてつなげる命名規則（名前の付け方）です。Swiftでは一般的です。"),
        ("関数", "関数は、「特定の処理」をひとまとめにし、名前をつけたものです。func キーワードで作成し、何度も呼び出して使えます。"),
        ("クロージャ", "クロージャは、関数のように「処理をひとまとめ」にしたものです。名前を付けずに関数の引数として渡したり、変数に代入したりできる機能です。"),
        ("プロパティ", "プロパティは、クラスや構造体の中に保存される「データ」や「変数」のことです。（例：User クラスの name プロパティ）"),
        ("イニシャライザ", "イニシャライザは、init キーワードで定義する、インスタンスが作成されるときに「初期化（下準備）」を行うための特別なメソッドです。"),
        ("メソッド", "メソッドは、クラスや構造体の中に定義（作成）される「関数（処理）」のことです。（例：Calculator クラスの add() メソッド）"),
        ("Class", "Classは、class キーワードで作成する、「設計図」です。構造体と似ていますが、参照型であり、継承ができるなど、より高機能です。"),
        ("構造体", "構造体は、struct キーワードで作成する、データ（プロパティ）や機能（メソッド）をまとめるための「設計図」です。値型です。"),
        ("列挙型", "列挙型は、enum キーワードで作成する、「複数の関連する選択肢」をまとめるための型です。（例：「赤」「青」「黄」など）"),
        ("制御構文", "制御構文は、if 文や for-in 文など、プログラムの処理の流れをコントロール（制御）するための文法です。"),
        ("モジュール", "モジュールは、コードをまとめる「単位」です。通常、一つのアプリや一つのフレームワークが、一つのモジュールにあたります。"),
        ("非同期処理", "非同期処理は、「時間のかかる処理」（例：ネットワーク通信）をメインの処理とは別（バックグラウンド）で行い、メインの処理を止めない仕組みで行われる処理そのものです。Swift 6では async/await 構文が標準です。"),
        ("エラー処理", "エラー処理は、処理が失敗する（エラーが起きる）可能性がある場合に、それを適切にキャッチ（捕獲）して、安全に回復処理を行う仕組みです。"),
        ("ユニットテスト", "ユニットテストは、関数やメソッドなど、コードの「小さな単位（ユニット）」が正しく動作するかどうかを確認するテストです。"),
        ("型安全", "型安全は、Swiftの基本的な考え方で、変数や定数には決まった型しか入れられないというルールです。これにより、予期せぬエラーを防ぎます。"),
        ("var", "varは、「変数」を宣言（作成）するためのキーワードです。中身を後から変更できる箱のようなものです。"),
        ("let", "letは、「定数」を宣言（作成）するためのキーワードです。一度入れたら中身を変更できない箱のようなものです。"),
        ("スコープ", "スコープは、変数や定数が「有効な（参照できる）範囲」のことです。例えば、関数の中で宣言した変数は、その関数の外からは使えません。"),
        ("ローカルスコープ", "ローカルスコープは、関数や if 文の {} 内部など、特定のブロック内に限定されたスコープです。"),
        ("グローバルスコープ", "グローバルスコープは、プログラム全体のどこからでもアクセスできる、最も外側のスコープです。"),
        ("リテラル", "リテラルは、コードの中に直接書く「値」そのものです。例えば 123 (整数リテラル) や \"ハロー\" (文字列リテラル) です。"),
        ("String型", "String型は、「こんにちは」や「ABC」のような、文字列（テキスト）を扱うための型（データの種類）です。"),
        ("符合演算子", "符合演算子は、数値のプラス・マイナスを切り替える - (例: -5) のような演算子です。"),
        ("否定演算子", "否定演算子は、Bool型の true と false を反転させる ! (例: !true は false) の演算子です。"),
        ("Bool型", "Bool型は、true (真) / false (偽) のどちらか、つまり「正しいか、間違っているか」の2択だけを扱うための型です。"),
        ("真理値リテラル", "真理値リテラルは、true と false のことです。"),
        ("論理演算", "論理演算は、複数の条件を組み合わせて true / false を判断するための計算です。"),
        ("論理積", "論理積は、「A かつ B」という意味の演算子 && です。両方が true の場合のみ true になります。"),
        ("論理和", "論理和は、「A または B」という意味の演算子 || です。どちらか一方でも true なら true になります。"),
        ("浮動小数点型", "浮動小数点型は、Float や Double のことで、3.14 や -0.5 のような、小数点を含む数値を扱うための型です。"),
        ("Optional<Wrapped>型", "Optional<Wrapped>型は、「値があるかもしれないし、nil（何もない）かもしれない」状態を表現するための型です。安全に「値なし」を扱うために使います。"),
        ("nilリテラル", "nilリテラルは、コード上に書く nil そのものを指します。"),
        ("オプショナルバインディング", "オプショナルバインディングは、if let や guard let を使い、オプショナル型から安全に中身（値）を取り出す方法です。"),
        ("??演算子", "??演算子は、オプショナル型の値が nil だった場合に、代わりに使うデフォルト値（初期値）を指定できる演算子です。"),
        ("強制アンラップ", "強制アンラップは、オプショナル型の変数名の後ろに ! をつけ、「絶対に nil ではない」と宣言して、中身を無理やり取り出す方法です。もし nil だとアプリがクラッシュします。"),
        ("オプショナルチェイン", "オプショナルチェインは、オプショナル型のプロパティやメソッドを ? でつないでいく記法です。途中で nil があった場合、それ以降の処理は行われず、結果は nil になります。"),
        ("暗黙的にアンラップ", "暗黙的にアンラップは、型名の後ろに ! をつけて宣言するオプショナル型です。使うときに自動で強制アンラップされますが、nil のまま使うとクラッシュします。"),
        ("Any型", "Any型は、どんな型（数値、文字列、クラスなど）でも代入できる、特別な型です。ただし、使うときは注意が必要です。"),
        ("タプル型", "タプル型は、複数の値を一時的にひとまとめにするための型です。(1, \"りんご\") のように、異なる型を組み合わせられます。"),
        ("インデックス", "インデックスは、Array（配列）などで、データの「順番」（何番目か）を示す番号です。通常0から始まります。"),
        ("型のキャスト", "型のキャストは、ある型（例：スーパークラス型）として扱われているインスタンスを、別の型（例：サブクラス型）として「変換」しようとすることです。"),
        ("アップキャスト", "アップキャストは、サブクラス（子）からスーパークラス（親）へ、より抽象的な型へ変換することです。これは常に安全です。（例：Dog を Animal として扱う）"),
        ("ダウンキャスト", "ダウンキャストは、スーパークラス（親）からサブクラス（子）へ、より具体的な型へ変換することです。as? や as! を使い、失敗する可能性があります。（例：Animal を Dog として扱う）"),
        ("プロトコル", "プロトコルは、「こういうプロパティやメソッドを持ってください」という「ルールの設計図（仕様書）」です。型に機能を追加する（準拠させる）ために使います。"),
        ("Equatableプロトコル", "Equatableプロトコルは、== 演算子で「等しいか」を比較できるようにするためのプロトコルです。"),
        ("Comparableプロトコル", "Comparableプロトコルは、< や > 演算子で「大小」を比較できるようにするためのプロトコルです。"),
        ("Array<Element>型", "Array<Element>型は、複数のデータを順番に並べて保存するための型です。[1, 2, 3] や [\"りんご\", \"バナナ\"] のように使います。"),
        ("map(_:)メソッド", "map(_:)メソッドは、配列などの各要素を、指定したルールで変換し、新しい配列を作るメソッドです。"),
        ("Dictionary<Key, Value>", "Dictionary<Key, Value>は、「キー」と「値」をペアにして保存する型です。[\"名前\": \"タナカ\", \"年齢\": 30] のように使い、キーを使って素早く値を取り出せます。"),
        ("範囲演算子", "範囲演算子は、1...5 (1から5まで) や 1..<5 (1から4まで) のように、数値の範囲を指定するための演算子です。"),
        ("シーケンス", "シーケンスは、for-in 文で繰り返し処理ができる「要素の集まり」のことです。Array や Dictionary もシーケンスの一種です。"),
        ("Sequenceプロトコル", "Sequenceプロトコルは、シーケンスが準拠する（守る）ルールのことです。map や forEach などの便利なメソッドが定義されています。"),
        ("条件分岐", "条件分岐は、「もしAならX、そうでなければY」のように、条件によって処理を分けることです。if 文や switch 文を使います。"),
        ("if文", "if文は、条件分岐の基本です。「もし〜なら、...する」という処理を書きます。"),
        ("else節", "else節は、if 文とセットで使い、「もし〜でなければ、...する」という処理を書きます。"),
        ("if-let文", "if-let文は、オプショナルバインディングの代表的な構文です。「もし値があれば、その値を使って処理する」という書き方です。"),
        ("guard文", "guard文は、「もし値が nil なら（条件を満たさなければ）、ここで処理を中断する」という構文です。オプショナルバインディングでよく使われます。"),
        ("switch文", "switch文は、一つの値が「どのケース（場合）に当てはまるか」で処理を分岐させる構文です。if 文より見やすくなる場合があります。"),
        ("辞書リテラル", "辞書リテラルは、[\"キー1\": 値1, \"キー2\": 値2] のように、Dictionary 型のデータを直接コードに書く方法です。"),
        ("演算子", "演算子は、+ (足し算) や = (代入) のように、計算や比較、代入などの操作を行うための記号です。"),
        ("Character型", "Character型は、「あ」や「A」のような、1文字だけを扱うための型です。"),
        ("forEach", "forEachは、配列などの各要素に対して、順番に処理を行うためのメソッドです。"),
        ("flatMap", "flatMapは、map の機能に加え、変換結果が nil だった場合は除外したり、ネストした（二重になった）配列を平らにしたりする高機能なメソッドです。"),
        ("break文", "break文は、for-in や switch などの繰り返し処理や分岐処理を、途中で強制的に中断（脱出）するために使います。"),
        ("for-in文", "for-in文は、配列（Array）などの要素を、最初から最後まで順番に取り出して繰り返し処理を行う構文です。"),
        ("continue文", "continue文は、for-in などの繰り返し処理で、現在の処理だけをスキップして、次の繰り返しに移るために使います。"),
        ("遅延実行", "遅延実行は、defer 文のように、処理を即座に行わず、特定のタイミング（スコープを抜ける時など）まで遅らせて実行することです。"),
        ("defer文", "defer文は、「後片付け」を予約する構文です。defer が書かれたスコープ（関数など）から抜けるときに、必ず実行されます。"),
        ("パターンマッチ", "パターンマッチは、switch 文などで、値が「特定のパターン（形）」に一致するかどうかを調べる機能です。"),
        ("式パターン", "式パターンは、case 1...10: のように、範囲演算子などを使って「式」でパターンを表現する方法です。"),
        ("バリューバインディングパターン", "バリューバインディングパターンは、case let value: や case .some(let value) のように、let や var を使って、マッチした値を一時的な定数や変数に取り出すパターンです。"),
        ("オプショナルパターン", "オプショナルパターンは、case let value?: のように ? を使い、オプショナル型の中身が nil でない場合にマッチさせ、値を取り出すパターンです。"),
        ("列挙型ケースパターン", "列挙型ケースパターンは、case .success(let data): のように、enum の特定のケース（と、その関連値）にマッチさせるパターンです。"),
        ("is演算子による型キャスティングパターン", "is演算子による型キャスティングパターンは、switch 文などで case is Dog: のように書き、「この型かどうか」をチェックするパターンです。"),
        ("as演算子による型キャスティングパターン", "as演算子による型キャスティングパターンは、case let dog as Dog: のように、ダウンキャストとバリューバインディングを同時に行うパターンです。"),
        ("as演算子", "as演算子は、型のキャスト（変換）を行うための演算子です。as (アップキャスト), as? (安全なダウンキャスト), as! (強制ダウンキャスト) があります。"),
        ("func", "funcは、関数 (Function) を定義（作成）するときに使うキーワードです。"),
        ("引数", "引数は、関数を呼び出すときに、その関数に渡す「情報」や「値」のことです。"),
        ("可変長引数", "可変長引数は、関数の引数を (numbers: Int...) のように宣言することで、0個以上の複数の値をまとめて受け取れるようにする機能です。"),
        ("戻り値", "戻り値は、関数が処理を実行した後、呼び出し元に返す「結果」の値です。"),
        ("インアウト引数", "インアウト引数は、通常、関数の引数は関数内で変更できませんが、inout キーワードを付けると、関数内で変更した値が呼び出し元の変数にも反映されるようになります。"),
        ("簡略引数名", "簡略引数名は、クロージャの中で、引数を $0 や $1 といった短い名前で自動的に参照できる機能です。"),
        ("escaping", "escapingは、クロージャが「関数の実行が終わった後でも使われる可能性がある」ことを示すキーワードです。非同期処理などで使われます。"),
        ("トレイリングクロージャ", "トレイリングクロージャは、関数の最後の引数がクロージャの場合に、() の外側にクロージャの処理を書くことができる記法です。コードが見やすくなります。"),
        ("インスタンス化", "インスタンス化は、設計図（クラスや構造体）から、実体（インスタンス）を作成することです。"),
        ("インスタンスプロパティ", "インスタンスプロパティは、インスタンスごとに個別に持つプロパティです。最も一般的なプロパティです。"),
        ("スタティックプロパティ", "スタティックプロパティは、static キーワードを付けたプロパティで、インスタンスを作らなくても、型そのもの（設計図）から直接アクセスできます。"),
        ("コンピューテッドプロパティ", "コンピューテッドプロパティは、値を保存せず、他のプロパティなどを使って計算した結果を返すプロパティです。"),
        ("ゲッタ", "ゲッタは、コンピューテッドプロパティなどで、値を「取得する」ときに呼ばれる処理ブロックです。"),
        ("失敗可能イニシャライザ", "失敗可能イニシャライザは、init? のように ? を付けて定義するイニシャライザです。初期化に失敗した場合に nil を返すことができます。"),
        ("nil", "nilは、「何もない」状態を表す特別な値です。オプショナル型の変数にのみ代入できます。"),
        ("self", "selfは、インスタンス自身（自分）を指すキーワードです。プロパティ名と引数名が被った時（self.name = name）などに使います。"),
        ("スタティックメソッド", "スタティックメソッドは、static キーワードを付けたメソッドで、インスタンスを作らなくても、型そのものから直接呼び出せます。"),
        ("オーバーロード", "オーバーロードは、同じ関数名でも、引数の型や個数が違えば、別の関数として定義（作成）できる機能です。"),
        ("サブスクリプト", "サブスクリプトは、array[0] や dictionary[\"key\"] のように、インスタンス名の後に [] を付けて値にアクセスする機能（構文）を、自分の型にも定義できる機能です。"),
        ("循環参照", "循環参照は、2つのインスタンス（クラス）が、お互いを強く参照し合い、ARCがカウントを0にできず、メモリから解放されなくなる問題です。"),
        ("セッタの省略", "セッタの省略は、コンピューテッドプロパティが「読み取り専用」（ゲッタのみ）の場合、get { ... } の部分を省略して書くことができます。"),
        ("エクステンション", "エクステンションは、extension キーワードを使い、既存のクラス、構造体、列挙型、プロトコルに、後から新しい機能（メソッドやプロパティ）を追加する機能です。"),
        ("型のネスト", "型のネストは、クラスや構造体の中に、別のクラスや構造体、列挙型を定義（作成）することです。"),
        ("The Composable Architecture(TCA)", "The Composable Architecture(TCA)は、状態管理、副作用、依存関係などを扱うための、宣言的な（わかりやすい）Swift用アーキテクチャ（設計手法）ライブラリの一つです。"),
        ("fatalError", "fatalErrorは、「絶対に起こってはいけない」重大なエラーが発生したときに呼び出す関数です。アプリは意図的にクラッシュ（終了）します。"),
        ("値型", "値型は、構造体や列挙型、Intなど、データそのものがコピーされて渡される型です。元のデータを変更しても、コピー先は影響を受けません。"),
        ("参照型", "参照型は、クラスなど、データが保存されている「場所（住所）」がコピーされて渡される型です。コピー先でデータを変更すると、元のデータも変わってしまいます。"),
        ("ストアドプロパティ", "ストアドプロパティは、値を単純に保存・保持するプロパティです。"),
        ("memberwise initializer", "memberwise initializerは、構造体（struct）で自動的に提供される、全てのプロパティを引数に取るイニシャライザのことです。"),
        ("継承", "継承は、あるクラス（スーパークラス）の機能（プロパティやメソッド）を引き継いで、新しいクラス（サブクラス）を作成することです。"),
        ("convenience initializer", "convenience initializerは、クラスのイニシャライザを補助する（便利にする）ためのイニシャライザです。必ず同じクラスの別のイニシャライザ（self.init(...)）を呼び出します。"),
        ("ARC（Automatic Reference Counting）", "ARC（Automatic Reference Counting）は、Swiftの自動メモリ管理システムです。インスタンスがどれだけ「参照されているか」を自動でカウントし、0になったらメモリから解放（削除）します。"),
        ("raw value", "raw valueは、列挙型（enum）の各ケースに、enum Status: Int { case a = 1 } のように割り当てる、あらかじめ決められた「元々の値」（例：IntやString）です。"),
        ("associated value", "associated valueは、列挙型（enum）の各ケースに、case success(Data) のように、そのケースが選ばれた時だけ持つことができる「関連する値」です。"),
        ("CaseIterable", "CaseIterableは、列挙型（enum）に準拠させると、allCases プロパティで全てのケースを配列として取得できるようになるプロトコルです。"),
        ("Hashable", "Hashableは、値を「ハッシュ化」（ユニークな数値に変換）できるようにするプロトコルです。Dictionaryのキーになるために必要です。"),
        ("プロトコルコンポジション", "プロトコルコンポジションは、ProtocolA & ProtocolB のように、複数のプロトコルを & で組み合わせて、「両方のルールを満たす型」として扱う方法です。"),
        ("セッタ", "セッタは、コンピューテッドプロパティなどで、値を「設定する」ときに呼ばれる処理ブロックです。"),
        ("mutatingキーワード", "mutatingキーワードは、値型（構造体や列挙型）のインスタンスメソッド内で、自分自身のプロパティを変更する（書き換える）場合に、func の前に付けるキーワードです。"),
        ("スーパークラス", "スーパークラスは、継承される側（親）のクラスです。"),
        ("プロトコルエクステンション", "プロトコルエクステンションは、プロトコル自体をエクステンション（拡張）し、そのプロトコルに準拠する型が共通で使えるメソッドなどを「まとめて実装」する機能です。"),
        ("型制約", "型制約は、ジェネリクスで、「仮型引数 T は、必ず Equatable プロトコルに準拠している型にしてください」のように、型に条件（制約）を付ける機能です。"),
        ("仮型引数", "仮型引数は、ジェネリクスを定義する際に使う、T や Element といった「仮の型」の名前です。"),
        ("実型引数", "実型引数は、ジェネリクスを使う際に、仮型引数に当てはめる Int や String といった「実際の型」です。"),
        ("Swift Package Manager", "Swift Package Managerは、Swiftのコード（ライブラリ）を管理、ビルド、テスト、共有するための、Apple公式のツールです。"),
        ("import文", "import文は、import UIKit のように、他のモジュール（ライブラリやフレームワーク）の機能を使えるように「読み込む」ための命令です。"),
        ("アクセスコントロール", "アクセスコントロールは、public, internal, private などのキーワードを使い、プロパティやメソッドを「どこから呼び出せるか（公開範囲）」を制御する機能です。"),
        ("モジュールヘッダ", "モジュールヘッダは、モジュールが外部に公開するインターフェース（API）を定義するファイルやその情報のことです。"),
        ("インスタンス", "インスタンスは、クラスや構造体といった「設計図」をもとに、実際に作成された「実体（モノ）」のことです。"),
        ("非同期", "非同期は、「時間のかかる処理」（例：ネットワーク通信）をメインの処理とは別（バックグラウンド）で行い、メインの処理を止めない（フリーズさせない）仕組みです。"),
        ("デリゲートパターン", "デリゲートパターンは、あるオブジェクトの「処理の一部」を、別のオブジェクトに「委任（delegate）」する設計パターンです。"),
        ("Observerパターン", "Observerパターンは、あるオブジェクトの状態が「変化した」ときに、それを「監視（observe）」している別のオブジェクトに「通知」する設計パターンです。"),
        ("GCD", "GCDは、Grand Central Dispatchの略です。非同期処理や並列処理を簡単に行うための、iOS/macOSの低レベルな（基本的な）機能です。"),
        ("ディスパッチキュー", "ディスパッチキューは、GCDが管理する「処理の待ち行列」です。ここに処理（クロージャ）を投げ込むと、適切なスレッドで実行してくれます。"),
        ("OperationQueue", "OperationQueueは、GCDをより高機能（例：処理の依存関係や中断）にしたものです。Operation という単位で処理を管理します。"),
        ("Operation", "Operationは、OperationQueue で実行される「処理」そのものをカプセル化（ひとまとめに）したオブジェクトです。"),
        ("Threadクラス", "Threadクラスは、処理を実行する「流れ（スレッド）」を直接管理する、より低レベルなクラスです。最近ではGCDや async/await を使うことが推奨されます。"),
        ("do-catch文", "do-catch文は、エラーが「投げられる(throw)」可能性のある関数を do ブロックで実行し、catch ブロックで発生したエラーを捕獲する構文です。"),
        ("Data型", "Data型は、画像、動画、JSONなど、特定の型を持たない「生のバイナリデータ」を扱うための型です。"),
        ("エンコード", "エンコードは、Swiftのデータ構造（クラスや構造体）を、JSONやProperty Listなどの「別のデータ形式」（通常はData型）に変換することです。"),
        ("デコード", "デコードは、JSONやProperty Listなどのデータ（Data型）を、Swiftのデータ構造（クラスや構造体）に「復元」することです。"),
        ("URLRequest型", "URLRequest型は、HTTP通信を行う際の「リクエスト（要求）」情報（URL、HTTPメソッド、ヘッダなど）をひとまとめにした型です。"),
        ("URLSessionクラス", "URLSessionクラスは、ネットワーク通信（HTTPリクエストなど）を行うための中心的なクラスです。"),
        ("XCTest", "XCTestは、Xcodeに組み込まれている、ユニットテストやUIテストを行うためのApple公式フレームワークです。"),
        ("テストコード", "テストコードは、XCTestフレームワークを使って、アプリ本体のコードをテストするために書くコードです。"),
        ("アサーション", "アサーションは、テストコードの中で、「この値はこうなるはずだ」と「主張（assert）」するための関数です。（例：XCTAssertEqual(a, b)）"),
        ("テストケース", "テストケースは、XCTestCase クラスを継承して作る、個々のテスト（test...() メソッド）をまとめるためのクラスです。"),
        ("スタブ", "スタブは、テスト対象のコードが依存している別の部品（例：ネットワーク通信）を、テスト用に単純な動作（例：固定のデータを返す）をする「ダミー（替え玉）」に置き換える手法、またはそのダミーのことです。"),
        ("async/await", "async/awaitは、Swiftの非同期処理を、逐次実行（上から順）のように読みやすく書くための構文です。"),
        ("構造化並行処理", "構造化並行処理は、Swiftの並行処理（Task）を、親子関係で安全に管理・キャンセルするための仕組みです。"),
        ("コンパイル", "コンパイルは、人間が書いたSwiftコードを、コンピュータが実行できる機械語に翻訳する作業です。"),
        ("データ競合", "データ競合は、複数の処理が同じデータに同時に書き込もうとし、予期せぬ動作を引き起こす問題です。"),
        ("Actor", "Actorは、データ競合を防ぐための型です。内部データへのアクセスを非同期化し、安全に保護します。"),
        ("completion handler", "completion handlerは、async/await登場以前の非同期処理で、処理完了時に呼び出されるクロージャです。"),
        ("concurrency safety", "concurrency safetyは、複数の処理を同時に動かしても、データ競合などが起きない「並行処理の安全性」です。"),
        ("TaskGroup", "TaskGroupは、複数の非同期タスクをグループ化し、並行実行・管理するための仕組みです。"),
        ("@MainActor", "@MainActorは、関数や型に付け、その処理を必ずUI更新用のメインスレッドで実行させる属性です。"),
        ("Sendable プロトコル", "Sendable プロトコルは、型が並行処理の境界（Actor間など）を越えて安全に渡せることを示すルールです。"),
        ("Structured Concurrency", "Structured Concurrencyは、「構造化並行処理」の英語名で、Taskを親子関係で安全に管理する仕組みです。")
    ]
    
    // 初期データを投入する
    func seedInitialData(context: ModelContext) {
        // 「Swift」フォルダが既に存在するかチェック
        let descriptor = FetchDescriptor<Deck>(
            predicate: #Predicate<Deck> { deck in
                deck.name == "Swift"
            }
        )
        
        do {
            let existingDecks = try context.fetch(descriptor)
            
            // 既に存在する場合は何もしない
            if !existingDecks.isEmpty {
                print("✅ Swiftフォルダは既に存在します")
                return
            }
            
            // 「Swift」フォルダを作成
            let swiftDeck = Deck(name: "Swift")
            context.insert(swiftDeck)
            
            // 全てのカードを作成して追加
            for (term, definition) in swiftGlossary {
                let card = Card(term: term, definition: definition, deck: swiftDeck)
                context.insert(card)
            }
            
            // 保存
            try context.save()
            print("✅ 初期データ投入完了: \(swiftGlossary.count)枚のカードを追加しました")
            
        } catch {
            print("❌ 初期データ投入エラー: \(error)")
        }
    }
}
